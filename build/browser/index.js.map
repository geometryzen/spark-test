{"version":3,"file":"index.js","sources":["../module/cst/parser.js","../module/cst/splitSourceTextIntoLines.js","../module/common/tree.js","../module/common/Range.js","../module/common/Position.js","../module/common/syntaxError.js","../../node_modules/tslib/tslib.es6.js","../module/cst/grammarName.js","../module/cst/tokenNames.js","../module/cst/Tokenizer.js","../module/common/TokenError.js","../module/common/base.js","../module/common/asserts.js","../module/cst/tables.js","../module/cst/Tokens.js"],"sourcesContent":["import { IDX_DFABT_DFA, IDX_DFABT_BEGIN_TOKENS } from './tables';\nimport { ARC_SYMBOL_LABEL, ARC_TO_STATE, OpMap, ParseTables } from './tables';\nimport { assert } from '../common/asserts';\nimport { Tokenizer } from './Tokenizer';\nimport { Tokens } from './Tokens';\nimport { tokenNames } from './tokenNames';\nimport { grammarName } from './grammarName';\nimport { parseError } from '../common/syntaxError';\nimport { Position } from '../common/Position';\nimport { Range } from '../common/Range';\nimport { splitSourceTextIntoLines } from './splitSourceTextIntoLines';\n// Dereference certain tokens for performance.\nvar T_COMMENT = Tokens.T_COMMENT;\nvar T_ENDMARKER = Tokens.T_ENDMARKER;\nvar T_NAME = Tokens.T_NAME;\nvar T_NL = Tokens.T_NL;\nvar T_NT_OFFSET = Tokens.T_NT_OFFSET;\nvar T_OP = Tokens.T_OP;\n// low level parser to a concrete syntax tree, derived from cpython's lib2to3\n// TODO: The parser does not report whitespace nodes.\n// It would be nice if there were an ignoreWhitespace option.\nvar Parser = (function () {\n    /**\n     *\n     */\n    function Parser(grammar) {\n        this.stack = [];\n        this.used_names = {};\n        this.grammar = grammar;\n    }\n    Parser.prototype.setup = function (start) {\n        start = start || this.grammar.start;\n        var newnode = {\n            type: start,\n            range: null,\n            value: null,\n            children: []\n        };\n        var stackentry = {\n            dfa: this.grammar.dfas[start][IDX_DFABT_DFA],\n            beginTokens: this.grammar.dfas[start][IDX_DFABT_BEGIN_TOKENS],\n            stateId: 0,\n            node: newnode\n        };\n        this.stack.push(stackentry);\n    };\n    /**\n     * Add a token; return true if we're done.\n     * @param type\n     * @param value\n     * @param context [start, end, line]\n     */\n    Parser.prototype.addtoken = function (type, value, begin, end, line) {\n        /**\n         * The symbol for the token being added.\n         */\n        var tokenSymbol = this.classify(type, value, begin, end, line);\n        /**\n         * Local variable for performance.\n         */\n        var stack = this.stack;\n        // More local variables for performance.\n        var g = this.grammar;\n        var dfas = g.dfas;\n        var labels = g.labels;\n        // This code is very performance sensitive.\n        OUTERWHILE: while (true) {\n            var stackTop = stack[stack.length - 1];\n            var dfa = stackTop.dfa;\n            // This is not being used. Why?\n            // let first = tp.dfa[DFA_SECOND];\n            var arcs = dfa[stackTop.stateId];\n            // look for a to-state with this label\n            for (var _i = 0, arcs_1 = arcs; _i < arcs_1.length; _i++) {\n                var arc = arcs_1[_i];\n                var arcSymbol = arc[ARC_SYMBOL_LABEL];\n                var newState = arc[ARC_TO_STATE];\n                var t = labels[arcSymbol][0];\n                // const v = labels[arcSymbol][1];\n                // console.lg(`t => ${t}, v => ${v}`);\n                if (tokenSymbol === arcSymbol) {\n                    this.shiftToken(type, value, newState, begin, end, line);\n                    // pop while we are in an accept-only state\n                    var stateId = newState;\n                    /**\n                     * Temporary variable to save a few CPU cycles.\n                     */\n                    var statesOfState = dfa[stateId];\n                    while (statesOfState.length === 1 && statesOfState[0][ARC_SYMBOL_LABEL] === 0 && statesOfState[0][ARC_TO_STATE] === stateId) {\n                        this.popNonTerminal();\n                        // Much of the time we won't be done so cache the stack length.\n                        var stackLength = stack.length;\n                        if (stackLength === 0) {\n                            // done!\n                            return true;\n                        }\n                        else {\n                            stackTop = stack[stackLength - 1];\n                            stateId = stackTop.stateId;\n                            dfa = stackTop.dfa;\n                            // first = stackTop.beginTokens;\n                            // first = top.dfa[1];\n                            statesOfState = dfa[stateId];\n                        }\n                    }\n                    // done with this token\n                    return false;\n                }\n                else if (isNonTerminal(t)) {\n                    var dfabt = dfas[t];\n                    var dfa_1 = dfabt[IDX_DFABT_DFA];\n                    var beginTokens = dfabt[IDX_DFABT_BEGIN_TOKENS];\n                    if (beginTokens.hasOwnProperty(tokenSymbol)) {\n                        this.pushNonTerminal(t, dfa_1, beginTokens, newState, begin, end, line);\n                        continue OUTERWHILE;\n                    }\n                }\n            }\n            // We've exhaused all the arcs for the for the state.\n            if (existsTransition(arcs, [T_ENDMARKER, stackTop.stateId])) {\n                // an accepting state, pop it and try something else\n                this.popNonTerminal();\n                if (stack.length === 0) {\n                    throw parseError(\"too much input\");\n                }\n            }\n            else {\n                var found = grammarName(stackTop.stateId);\n                // FIXME:\n                throw parseError(\"Unexpected \" + found + \" at \" + JSON.stringify([begin[0], begin[1] + 1]), begin, end);\n            }\n        }\n    };\n    /**\n     * Turn a token into a symbol (something that labels an arc in the DFA).\n     * The context is only used for error reporting.\n     * @param type\n     * @param value\n     * @param context [begin, end, line]\n     */\n    Parser.prototype.classify = function (type, value, begin, end, line) {\n        // Assertion commented out for efficiency.\n        assertTerminal(type);\n        var g = this.grammar;\n        if (type === T_NAME) {\n            this.used_names[value] = true;\n            var keywordToSymbol = g.keywords;\n            if (keywordToSymbol.hasOwnProperty(value)) {\n                var ilabel_1 = keywordToSymbol[value];\n                // assert(typeof ilabel === 'number', \"How can it not be?\");\n                return ilabel_1;\n            }\n        }\n        var tokenToSymbol = g.tokens;\n        var ilabel;\n        if (tokenToSymbol.hasOwnProperty(type)) {\n            ilabel = tokenToSymbol[type];\n        }\n        if (!ilabel) {\n            console.log(\"ilabel = \" + ilabel + \", type = \" + type + \", value = \" + value + \", begin = \" + JSON.stringify(begin) + \", end = \" + JSON.stringify(end));\n            throw parseError(\"bad token\", begin, end);\n        }\n        return ilabel;\n    };\n    /**\n     * Shifting a token (terminal).\n     * 1. A new node is created representing the token.\n     * 2. The new node is added as a child to the topmost node on the stack.\n     * 3. The state of the topmost element on the stack is updated to be the new state.\n     */\n    Parser.prototype.shiftToken = function (type, value, newState, begin, end, line) {\n        // assertTerminal(type);\n        // Local variable for efficiency.\n        var stack = this.stack;\n        /**\n         * The topmost element in the stack is affected by shifting a token.\n         */\n        var stackTop = stack[stack.length - 1];\n        var node = stackTop.node;\n        var newnode = {\n            type: type,\n            value: value,\n            range: new Range(new Position(begin[0], begin[1]), new Position(end[0], end[1])),\n            children: null\n        };\n        if (newnode && node.children) {\n            node.children.push(newnode);\n        }\n        stackTop.stateId = newState;\n    };\n    /**\n     * Push a non-terminal symbol onto the stack as a new node.\n     * 1. Update the state of the topmost element on the stack to be newState.\n     * 2. Push a new element onto the stack corresponding to the symbol.\n     * The new stack elements uses the newDfa and has state 0.\n     */\n    Parser.prototype.pushNonTerminal = function (type, dfa, beginTokens, newState, begin, end, line) {\n        // Based on how this function is called, there is really no need for this assertion.\n        // Retain it for now while it is not the performance bottleneck.\n        // assertNonTerminal(type);\n        // Local variable for efficiency.\n        var stack = this.stack;\n        var stackTop = stack[stack.length - 1];\n        stackTop.stateId = newState;\n        var beginPos = begin ? new Position(begin[0], begin[1]) : null;\n        var endPos = end ? new Position(end[0], end[1]) : null;\n        var newnode = { type: type, value: null, range: new Range(beginPos, endPos), children: [] };\n        // TODO: Is there a symbolic constant for the zero state?\n        stack.push({ dfa: dfa, beginTokens: beginTokens, stateId: 0, node: newnode });\n    };\n    /**\n     * Pop a nonterminal.\n     * Popping an element from the stack causes the node to be added to the children of the new top element.\n     * The exception is when the stack becomes empty, in which case the node becomes the root node.\n     */\n    Parser.prototype.popNonTerminal = function () {\n        // Local variable for efficiency.\n        var stack = this.stack;\n        var poppedElement = stack.pop();\n        if (poppedElement) {\n            var poppedNode = poppedElement.node;\n            // Remove this assertion only when it becomes a performance issue.\n            // assertNonTerminal(poppedNode.type);\n            if (poppedNode) {\n                /**\n                 * The length of the stack following the pop operation.\n                 */\n                var N = stack.length;\n                if (N !== 0) {\n                    var node = stack[N - 1].node;\n                    var children = node.children;\n                    if (children) {\n                        children.push(poppedNode);\n                    }\n                }\n                else {\n                    // If the length of the stack following the pop is zero then the popped element becomes the root node.\n                    this.rootNode = poppedNode;\n                    poppedNode.used_names = this.used_names;\n                }\n            }\n        }\n    };\n    return Parser;\n}());\n/**\n * FIXME: This is O(N). Can we do better?\n * Finds the specified\n * @param a An array of arrays where each element is an array of two integers.\n * @param obj An array containing two integers.\n */\nfunction existsTransition(arcs, obj) {\n    var i = arcs.length;\n    while (i--) {\n        var arc = arcs[i];\n        if (arc[ARC_SYMBOL_LABEL] === obj[ARC_SYMBOL_LABEL] && arc[ARC_TO_STATE] === obj[ARC_TO_STATE]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * parser for interactive input. returns a function that should be called with\n * lines of input as they are entered. the function will return false\n * until the input is complete, when it will return the rootnode of the parse.\n *\n * @param style root of parse tree (optional)\n */\nfunction makeParser(sourceKind) {\n    if (sourceKind === undefined)\n        sourceKind = SourceKind.File;\n    // FIXME: Would be nice to get this typing locked down. Why does Grammar not match ParseTables?\n    var p = new Parser(ParseTables);\n    // TODO: Can we do this over the symbolic constants?\n    switch (sourceKind) {\n        case SourceKind.File: {\n            p.setup(ParseTables.sym.Start);\n            break;\n        }\n        default: {\n            throw new Error(\"SourceKind must be one of File, Eval, or Single.\");\n        }\n    }\n    var lineno = 1;\n    var column = 0;\n    var prefix = \"\";\n    var tokenizer = new Tokenizer(false /*sourceKind === SourceKind.Single*/, function tokenizerCallback(type, value, start, end, line) {\n        // var s_lineno = start[0];\n        // var s_column = start[1];\n        /*\n        if (s_lineno !== lineno && s_column !== column)\n        {\n            // todo; update prefix and line/col\n        }\n        */\n        if (type === T_COMMENT || type === T_NL) {\n            prefix += value;\n            lineno = end[0];\n            column = end[1];\n            if (value[value.length - 1] === \"\\n\") {\n                lineno += 1;\n                column = 0;\n            }\n            return undefined;\n        }\n        if (type === T_OP) {\n            type = OpMap[value];\n        }\n        // FIXME: We're creating an array object here for every token.\n        if (p.addtoken(type, value, start, end, line)) {\n            return true;\n        }\n        return undefined;\n    });\n    return function parseFunc(line) {\n        var ret = tokenizer.generateTokens(line);\n        if (ret) {\n            if (ret !== \"done\") {\n                throw parseError(\"incomplete input\");\n            }\n            return p.rootNode;\n        }\n        return false;\n    };\n}\n/**\n * Determines the starting point in the grammar for parsing the source.\n */\nexport var SourceKind;\n(function (SourceKind) {\n    /**\n     * Suitable for a module.\n     */\n    SourceKind[SourceKind[\"File\"] = 0] = \"File\";\n    /**\n     * Suitable for execution.\n     */\n    SourceKind[SourceKind[\"Eval\"] = 1] = \"Eval\";\n    /**\n     * Suitable for a REPL.\n     */\n    SourceKind[SourceKind[\"Single\"] = 2] = \"Single\";\n})(SourceKind || (SourceKind = {}));\nexport function parse(sourceText, sourceKind) {\n    if (sourceKind === void 0) { sourceKind = SourceKind.File; }\n    var parser = makeParser(sourceKind);\n    var lines = splitSourceTextIntoLines(sourceText);\n    // FIXME: Mixing the types this way is awkward for the consumer.\n    var ret = false;\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        ret = parser(line);\n    }\n    return ret;\n}\n/**\n * Concrete Syntax Tree\n */\nexport function cstDump(parseTree) {\n    function parseTreeDump(n, indent) {\n        var ret = \"\";\n        if (isNonTerminal(n.type)) {\n            ret += indent + ParseTables.number2symbol[n.type] + \"\\n\";\n            if (n.children) {\n                for (var i = 0; i < n.children.length; ++i) {\n                    ret += parseTreeDump(n.children[i], \"  \" + indent);\n                }\n            }\n        }\n        else {\n            ret += indent + tokenNames[n.type] + \": \" + n.value + \"\\n\";\n        }\n        return ret;\n    }\n    return parseTreeDump(parseTree, \"\");\n}\n/**\n * Terminal symbols hsould be less than T_NT_OFFSET.\n * NT_OFFSET means non-terminal offset.\n */\nfunction assertTerminal(type) {\n    assert(type < T_NT_OFFSET, \"terminal symbols should be less than T_NT_OFFSET\");\n}\n/*\nfunction assertNonTerminal(type: number): void {\n    assert(isNonTerminal(type), \"non terminal symbols should be greater than or equal to T_NT_OFFSET\");\n}\n*/\nfunction isNonTerminal(type) {\n    return type >= T_NT_OFFSET;\n}\n","import { IDXLAST } from '../common/tree';\n/**\n * Prepare the source text into lines to feed to the `generateTokens` method of the tokenizer.\n */\nexport function splitSourceTextIntoLines(sourceText) {\n    var lines = [];\n    // Why do we normalize the sourceText in this manner?\n    if (sourceText.substr(IDXLAST(sourceText), 1) !== \"\\n\") {\n        sourceText += \"\\n\";\n    }\n    // Splitting this way will create a final line that is the zero-length string.\n    var pieces = sourceText.split(\"\\n\");\n    var N = pieces.length;\n    for (var i = 0; i < N; ++i) {\n        // We're adding back newline characters for all but the last line.\n        var line = pieces[i] + ((i === IDXLAST(pieces)) ? \"\" : \"\\n\");\n        lines.push(line);\n    }\n    return lines;\n}\n","import { assert } from './asserts';\n/**\n * Returns the number of children in the specified node.\n */\nexport function NCH(n) {\n    assert(n !== undefined);\n    if (Array.isArray(n.children)) {\n        return n.children.length;\n    }\n    else {\n        return 0;\n    }\n}\nexport function CHILD(n, i) {\n    assert(i !== undefined && i >= 0);\n    return CHILDREN(n)[i];\n}\nexport function FIND(n, type) {\n    assert(type !== undefined);\n    var children = CHILDREN(n);\n    var N = children.length;\n    for (var i = 0; i < N; i++) {\n        var child = children[i];\n        if (child.type === type) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function CHILDREN(n) {\n    assert(n !== undefined);\n    if (n.children) {\n        return n.children;\n    }\n    else {\n        throw new Error(\"node does not have any children\");\n    }\n}\nexport function IDXLAST(xs) {\n    return xs.length - 1;\n}\n/**\n * Returns the terminal nodes of the tree.\n */\nexport function TERMS(n) {\n    var childLength = NCH(n);\n    if (childLength === 0) {\n        return [n];\n    }\n    else {\n        var terminals = [];\n        for (var _i = 0, _a = CHILDREN(n); _i < _a.length; _i++) {\n            var child = _a[_i];\n            for (var _b = 0, _c = TERMS(child); _b < _c.length; _b++) {\n                var t = _c[_b];\n                terminals.push(t);\n            }\n        }\n        return terminals;\n    }\n}\n","import { assert } from './asserts';\nvar Range = (function () {\n    /**\n     *\n     */\n    function Range(begin, end) {\n        assert(begin, \"begin must be defined\");\n        assert(end, \"end must be defined\");\n        this.begin = begin;\n        this.end = end;\n    }\n    Range.prototype.toString = function () {\n        return this.begin + \" to \" + this.end;\n    };\n    return Range;\n}());\nexport { Range };\n","var Position = (function () {\n    /**\n     *\n     */\n    function Position(line, column) {\n        this.line = line;\n        this.column = column;\n    }\n    Position.prototype.toString = function () {\n        return \"[\" + this.line + \", \" + this.column + \"]\";\n    };\n    return Position;\n}());\nexport { Position };\nexport function positionComparator(a, b) {\n    if (a.line < b.line) {\n        return -1;\n    }\n    else if (a.line > b.line) {\n        return 1;\n    }\n    else {\n        if (a.column < b.column) {\n            return -1;\n        }\n        else if (a.column > b.column) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n","import * as tslib_1 from \"tslib\";\nimport { assert } from './asserts';\nimport { isDef, isNumber, isString } from './base';\n/**\n * @param message\n * @param lineNumber\n */\nexport function syntaxError(message, range) {\n    assert(isString(message), \"message must be a string\");\n    if (isDef(range)) {\n        assert(isNumber(range.begin.line), \"lineNumber must be a number\");\n    }\n    var e = new SyntaxError(message /*, fileName*/);\n    if (typeof range.begin.line === 'number') {\n        e['lineNumber'] = range.begin.line;\n    }\n    return e;\n}\nvar ParseError = (function (_super) {\n    tslib_1.__extends(ParseError, _super);\n    function ParseError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'ParseError';\n        return _this;\n    }\n    return ParseError;\n}(SyntaxError));\nexport { ParseError };\n/**\n * @param message\n * @param begin\n * @param end\n */\nexport function parseError(message, begin, end) {\n    var e = new ParseError(message);\n    // Copying from begin and end is important because they change for each token.\n    // Notice that the Line is 1-based, but that row is 0-based.\n    // Both column and Column are 0-based.\n    if (Array.isArray(begin)) {\n        e.begin = { row: begin[0] - 1, column: begin[1] };\n    }\n    if (Array.isArray(end)) {\n        e.end = { row: end[0] - 1, column: end[1] };\n    }\n    return e;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","import { ParseTables } from './tables';\nimport { tokenNames } from './tokenNames';\nexport function grammarName(type) {\n    var tokenName = tokenNames[type];\n    if (tokenName) {\n        return tokenName;\n    }\n    else {\n        return ParseTables.number2symbol[type];\n    }\n}\n","import { Tokens } from './Tokens';\n/**\n * Decodes of the tokens.\n * A mapping from the token number (symbol) to its human-readable name.\n */\nexport var tokenNames = {};\ntokenNames[Tokens.T_COLON] = 'COLON';\ntokenNames[Tokens.T_COMMENT] = 'COMMENT';\ntokenNames[Tokens.T_DEDENT] = 'DEDENT';\ntokenNames[Tokens.T_ENDMARKER] = 'ENDMARKER';\ntokenNames[Tokens.T_ERRORTOKEN] = 'ERRORTOKEN';\ntokenNames[Tokens.T_INDENT] = 'INDENT';\ntokenNames[Tokens.T_LPAR] = 'LPAR';\ntokenNames[Tokens.T_N_TOKENS] = 'N_TOKENS';\ntokenNames[Tokens.T_NAME] = 'NAME';\ntokenNames[Tokens.T_NEWLINE] = 'NEWLINE';\ntokenNames[Tokens.T_NL] = 'NL';\ntokenNames[Tokens.T_NT_OFFSET] = 'NT_OFFSET';\ntokenNames[Tokens.T_NUMBER] = 'NUMBER';\ntokenNames[Tokens.T_OP] = 'OP';\ntokenNames[Tokens.T_RARROW] = 'RARROW';\ntokenNames[Tokens.T_RPAR] = 'RPAR';\ntokenNames[Tokens.T_STRING] = 'STRING';\n","import { assert } from '../common/asserts';\nimport { TokenError } from '../common/TokenError';\nimport { Tokens } from './Tokens';\n// Cache a few tokens for performance.\nvar T_COMMENT = Tokens.T_COMMENT;\nvar T_DEDENT = Tokens.T_DEDENT;\nvar T_ENDMARKER = Tokens.T_ENDMARKER;\nvar T_ERRORTOKEN = Tokens.T_ERRORTOKEN;\nvar T_INDENT = Tokens.T_INDENT;\nvar T_NAME = Tokens.T_NAME;\nvar T_NEWLINE = Tokens.T_NEWLINE;\nvar T_NL = Tokens.T_NL;\nvar T_NUMBER = Tokens.T_NUMBER;\nvar T_OP = Tokens.T_OP;\nvar T_STRING = Tokens.T_STRING;\n/* we have to use string and ctor to be able to build patterns up. + on /.../\n    * does something strange. */\n// const Whitespace = \"[ \\\\f\\\\t]*\";\nvar Comment_ = \"#[^\\\\r\\\\n]*\";\nvar Ident = \"[a-zA-Z_]\\\\w*\";\nvar Binnumber = '0[bB][01]*';\nvar Hexnumber = '0[xX][\\\\da-fA-F]*[lL]?';\nvar Octnumber = '0[oO]?[0-7]*[lL]?';\nvar Decnumber = '[1-9]\\\\d*[lL]?';\nvar Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);\nvar Exponent = \"[eE][-+]?\\\\d+\";\nvar Pointfloat = group(\"\\\\d+\\\\.\\\\d*\", \"\\\\.\\\\d+\") + maybe(Exponent);\nvar Expfloat = '\\\\d+' + Exponent;\nvar Floatnumber = group(Pointfloat, Expfloat);\nvar Imagnumber = group(\"\\\\d+[jJ]\", Floatnumber + \"[jJ]\");\nvar Number_ = group(Imagnumber, Floatnumber, Intnumber);\n// tail end of ' string\nvar Single = \"^[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\";\n// tail end of \" string\nvar Double_ = '^[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"';\n// tail end of ''' string\nvar Single3 = \"[^'\\\\\\\\]*(?:(?:\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*'''\";\n// tail end of \"\"\" string\nvar Double3 = '[^\"\\\\\\\\]*(?:(?:\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*\"\"\"';\nvar Triple = group(\"[ubUB]?[rR]?'''\", '[ubUB]?[rR]?\"\"\"');\n// const String_ = group(\"[uU]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*'\", '[uU]?[rR]?\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*\"');\n// Because of leftmost-then-longest match semantics, be sure to put the\n// longest operators first (e.g., if = came before ==, == would get\n// recognized as two instances of =).\nvar Operator = group(\"\\\\*\\\\*=?\", \">>=?\", \"<<=?\", \"<>\", \"!=\", \"//=?\", \"->\", \"[+\\\\-*/%&|^=<>]=?\", \"~\");\nvar Bracket = '[\\\\][(){}]';\nvar Special = group('\\\\r?\\\\n', '[:;.,`@]');\nvar Funny = group(Operator, Bracket, Special);\nvar ContStr = group(\"[uUbB]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*\" +\n    group(\"'\", '\\\\\\\\\\\\r?\\\\n'), '[uUbB]?[rR]?\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*' +\n    group('\"', '\\\\\\\\\\\\r?\\\\n'));\nvar PseudoExtras = group('\\\\\\\\\\\\r?\\\\n', Comment_, Triple);\n// Need to prefix with \"^\" as we only want to match what's next\nvar PseudoToken = \"^\" + group(PseudoExtras, Number_, Funny, ContStr, Ident);\nvar pseudoprog = new RegExp(PseudoToken);\nvar single3prog = new RegExp(Single3, \"g\");\nvar double3prog = new RegExp(Double3, \"g\");\nvar endprogs = {\n    \"'\": new RegExp(Single, \"g\"), '\"': new RegExp(Double_, \"g\"),\n    \"'''\": single3prog, '\"\"\"': double3prog,\n    \"r'''\": single3prog, 'r\"\"\"': double3prog,\n    \"u'''\": single3prog, 'u\"\"\"': double3prog,\n    \"b'''\": single3prog, 'b\"\"\"': double3prog,\n    \"ur'''\": single3prog, 'ur\"\"\"': double3prog,\n    \"br'''\": single3prog, 'br\"\"\"': double3prog,\n    \"R'''\": single3prog, 'R\"\"\"': double3prog,\n    \"U'''\": single3prog, 'U\"\"\"': double3prog,\n    \"B'''\": single3prog, 'B\"\"\"': double3prog,\n    \"uR'''\": single3prog, 'uR\"\"\"': double3prog,\n    \"Ur'''\": single3prog, 'Ur\"\"\"': double3prog,\n    \"UR'''\": single3prog, 'UR\"\"\"': double3prog,\n    \"bR'''\": single3prog, 'bR\"\"\"': double3prog,\n    \"Br'''\": single3prog, 'Br\"\"\"': double3prog,\n    \"BR'''\": single3prog, 'BR\"\"\"': double3prog,\n    'r': null, 'R': null,\n    'u': null, 'U': null,\n    'b': null, 'B': null\n};\nvar triple_quoted = {\n    \"'''\": true, '\"\"\"': true,\n    \"r'''\": true, 'r\"\"\"': true, \"R'''\": true, 'R\"\"\"': true,\n    \"u'''\": true, 'u\"\"\"': true, \"U'''\": true, 'U\"\"\"': true,\n    \"b'''\": true, 'b\"\"\"': true, \"B'''\": true, 'B\"\"\"': true,\n    \"ur'''\": true, 'ur\"\"\"': true, \"Ur'''\": true, 'Ur\"\"\"': true,\n    \"uR'''\": true, 'uR\"\"\"': true, \"UR'''\": true, 'UR\"\"\"': true,\n    \"br'''\": true, 'br\"\"\"': true, \"Br'''\": true, 'Br\"\"\"': true,\n    \"bR'''\": true, 'bR\"\"\"': true, \"BR'''\": true, 'BR\"\"\"': true\n};\nvar single_quoted = {\n    \"'\": true, '\"': true,\n    \"r'\": true, 'r\"': true, \"R'\": true, 'R\"': true,\n    \"u'\": true, 'u\"': true, \"U'\": true, 'U\"': true,\n    \"b'\": true, 'b\"': true, \"B'\": true, 'B\"': true,\n    \"ur'\": true, 'ur\"': true, \"Ur'\": true, 'Ur\"': true,\n    \"uR'\": true, 'uR\"': true, \"UR'\": true, 'UR\"': true,\n    \"br'\": true, 'br\"': true, \"Br'\": true, 'Br\"': true,\n    \"bR'\": true, 'bR\"': true, \"BR'\": true, 'BR\"': true\n};\nvar tabsize = 8;\nvar NAMECHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';\nvar NUMCHARS = '0123456789';\n/**\n * For performance, let V8 know the size of an array.\n * The first element is the line number.\n * The line number is 1-based. This is intuitive because it maps to the way we think about line numbers.\n * The second element is the column.\n * The column is 0-based. This works well because it is the standard index for accessing strings.\n */\n/**\n * The index of the line in the LineColumn array.\n */\nvar LINE = 0;\n/**\n * The index of the column in the LineColumn array.\n */\nvar COLUMN = 1;\nexport var Done = 'done';\nexport var Failed = 'failed';\n/**\n * This is a port of tokenize.py by Ka-Ping Yee.\n *\n * each call to readline should return one line of input as a string, or\n * undefined if it's finished.\n *\n * callback is called for each token with 5 args:\n * 1. the token type\n * 2. the token string\n * 3. [ start_row, start_col ]\n * 4. [ end_row, end_col ]\n * 5. logical line where the token was found, including continuation lines\n *\n * callback can return true to abort.\n */\nvar Tokenizer = (function () {\n    /**\n     *\n     */\n    function Tokenizer(interactive, callback) {\n        this.callback = callback;\n        /**\n         * Cache of the beginning of a token.\n         * This will change by token so consumers must copy the values out.\n         */\n        this.begin = [-1, -1];\n        /**\n         * Cache of the end of a token.\n         * This will change by token so consumers must copy the values out.\n         */\n        this.end = [-1, -1];\n        /**\n         * The line number. This must be copied into the begin[LINE] and end[LINE] properties.\n         */\n        this.lnum = 0;\n        this.parenlev = 0;\n        /**\n         * Matches any character zero or more times.\n         * May change...\n         */\n        this.endprog = /.*/;\n        this.strstart = [-1, -1];\n        this.callback = callback;\n        this.continued = false;\n        this.contstr = '';\n        this.needcont = false;\n        this.contline = undefined;\n        this.indents = [0];\n        this.interactive = interactive;\n        this.doneFunc = function doneOrFailed() {\n            var begin = this.begin;\n            var end = this.end;\n            begin[LINE] = end[LINE] = this.lnum;\n            begin[COLUMN] = end[COLUMN] = 0;\n            var N = this.indents.length;\n            for (var i = 1; i < N; ++i) {\n                if (callback(T_DEDENT, '', begin, end, '')) {\n                    return Done;\n                }\n            }\n            if (callback(T_ENDMARKER, '', begin, end, '')) {\n                return Done;\n            }\n            return Failed;\n        };\n    }\n    /**\n     * @param line\n     * @return 'done' or 'failed' or true?\n     */\n    Tokenizer.prototype.generateTokens = function (line) {\n        var endmatch;\n        var column;\n        var endIndex;\n        if (!line) {\n            line = '';\n        }\n        this.lnum += 1;\n        var pos = 0;\n        var max = line.length;\n        /**\n         * Local variable for performance and brevity.\n         */\n        var callback = this.callback;\n        var begin = this.begin;\n        begin[LINE] = this.lnum;\n        var end = this.end;\n        end[LINE] = this.lnum;\n        if (this.contstr.length > 0) {\n            if (!line) {\n                throw new TokenError(\"EOF in multi-line string\", this.strstart[LINE], this.strstart[COLUMN]);\n            }\n            this.endprog.lastIndex = 0;\n            endmatch = this.endprog.test(line);\n            if (endmatch) {\n                pos = endIndex = this.endprog.lastIndex;\n                end[COLUMN] = endIndex;\n                if (callback(T_STRING, this.contstr + line.substring(0, endIndex), this.strstart, end, this.contline + line)) {\n                    return Done;\n                }\n                this.contstr = '';\n                this.needcont = false;\n                this.contline = undefined;\n            }\n            else if (this.needcont && line.substring(line.length - 2) !== \"\\\\\\n\" && line.substring(line.length - 3) !== \"\\\\\\r\\n\") {\n                // Either contline is a string or the callback must allow undefined.\n                assert(typeof this.contline === 'string');\n                end[COLUMN] = line.length;\n                if (callback(T_ERRORTOKEN, this.contstr + line, this.strstart, end, this.contline)) {\n                    return Done;\n                }\n                this.contstr = '';\n                this.contline = undefined;\n                return false;\n            }\n            else {\n                this.contstr += line;\n                this.contline = this.contline + line;\n                return false;\n            }\n        }\n        else if (this.parenlev === 0 && !this.continued) {\n            if (!line)\n                return this.doneFunc();\n            column = 0;\n            while (pos < max) {\n                var ch = line.charAt(pos);\n                if (ch === ' ') {\n                    column += 1;\n                }\n                else if (ch === '\\t') {\n                    column = (column / tabsize + 1) * tabsize;\n                }\n                else if (ch === '\\f') {\n                    column = 0;\n                }\n                else {\n                    break;\n                }\n                pos = pos + 1;\n            }\n            if (pos === max)\n                return this.doneFunc();\n            if (\"#\\r\\n\".indexOf(line.charAt(pos)) !== -1) {\n                if (line.charAt(pos) === '#') {\n                    var comment_token = rstrip(line.substring(pos), '\\r\\n');\n                    var nl_pos = pos + comment_token.length;\n                    begin[COLUMN] = pos;\n                    end[COLUMN] = nl_pos;\n                    if (callback(T_COMMENT, comment_token, begin, end, line)) {\n                        return Done;\n                    }\n                    begin[COLUMN] = nl_pos;\n                    end[COLUMN] = line.length;\n                    if (callback(T_NL, line.substring(nl_pos), begin, end, line)) {\n                        return Done;\n                    }\n                    return false;\n                }\n                else {\n                    begin[COLUMN] = pos;\n                    end[COLUMN] = line.length;\n                    if (callback(T_NL, line.substring(pos), begin, end, line)) {\n                        return Done;\n                    }\n                    if (!this.interactive)\n                        return false;\n                }\n            }\n            if (column > this.indents[this.indents.length - 1]) {\n                this.indents.push(column);\n                begin[COLUMN] = 0;\n                end[COLUMN] = pos;\n                if (callback(T_INDENT, line.substring(0, pos), begin, end, line)) {\n                    return Done;\n                }\n            }\n            while (column < this.indents[this.indents.length - 1]) {\n                if (!contains(this.indents, column)) {\n                    begin[COLUMN] = 0;\n                    end[COLUMN] = pos;\n                    throw indentationError(\"unindent does not match any outer indentation level\", begin, end, line);\n                }\n                this.indents.splice(this.indents.length - 1, 1);\n                begin[COLUMN] = pos;\n                end[COLUMN] = pos;\n                if (callback(T_DEDENT, '', begin, end, line)) {\n                    return Done;\n                }\n            }\n        }\n        else {\n            if (!line) {\n                throw new TokenError(\"EOF in multi-line statement\", this.lnum, 0);\n            }\n            this.continued = false;\n        }\n        while (pos < max) {\n            // js regexes don't return any info about matches, other than the\n            // content. we'd like to put a \\w+ before pseudomatch, but then we\n            // can't get any data\n            var capos = line.charAt(pos);\n            while (capos === ' ' || capos === '\\f' || capos === '\\t') {\n                pos += 1;\n                capos = line.charAt(pos);\n            }\n            pseudoprog.lastIndex = 0;\n            var pseudomatch = pseudoprog.exec(line.substring(pos));\n            if (pseudomatch) {\n                var startIndex = pos;\n                endIndex = startIndex + pseudomatch[1].length;\n                begin[COLUMN] = startIndex;\n                end[COLUMN] = endIndex;\n                pos = endIndex;\n                var token = line.substring(startIndex, endIndex);\n                var initial = line.charAt(startIndex);\n                if (NUMCHARS.indexOf(initial) !== -1 || (initial === '.' && token !== '.')) {\n                    if (callback(T_NUMBER, token, begin, end, line)) {\n                        return Done;\n                    }\n                }\n                else if (initial === '\\r' || initial === '\\n') {\n                    var newl = T_NEWLINE;\n                    if (this.parenlev > 0)\n                        newl = T_NL;\n                    if (callback(newl, token, begin, end, line)) {\n                        return Done;\n                    }\n                }\n                else if (initial === '#') {\n                    if (callback(T_COMMENT, token, begin, end, line)) {\n                        return Done;\n                    }\n                }\n                else if (triple_quoted.hasOwnProperty(token)) {\n                    this.endprog = endprogs[token];\n                    this.endprog.lastIndex = 0;\n                    endmatch = this.endprog.test(line.substring(pos));\n                    if (endmatch) {\n                        pos = this.endprog.lastIndex + pos;\n                        var token_1 = line.substring(startIndex, pos);\n                        end[COLUMN] = pos;\n                        if (callback(T_STRING, token_1, begin, end, line)) {\n                            return Done;\n                        }\n                    }\n                    else {\n                        this.strstart[LINE] = this.lnum;\n                        this.strstart[COLUMN] = startIndex;\n                        this.contstr = line.substring(startIndex);\n                        this.contline = line;\n                        return false;\n                    }\n                }\n                else if (single_quoted.hasOwnProperty(initial) ||\n                    single_quoted.hasOwnProperty(token.substring(0, 2)) ||\n                    single_quoted.hasOwnProperty(token.substring(0, 3))) {\n                    if (token[token.length - 1] === '\\n') {\n                        this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];\n                        assert(this.endprog instanceof RegExp);\n                        this.contstr = line.substring(startIndex);\n                        this.needcont = true;\n                        this.contline = line;\n                        return false;\n                    }\n                    else {\n                        if (callback(T_STRING, token, begin, end, line)) {\n                            return Done;\n                        }\n                    }\n                }\n                else if (NAMECHARS.indexOf(initial) !== -1) {\n                    if (callback(T_NAME, token, begin, end, line)) {\n                        return Done;\n                    }\n                }\n                else if (initial === '\\\\') {\n                    end[COLUMN] = pos;\n                    if (callback(T_NL, token, begin, end, line)) {\n                        return Done;\n                    }\n                    this.continued = true;\n                }\n                else {\n                    if ('([{'.indexOf(initial) !== -1) {\n                        this.parenlev += 1;\n                    }\n                    else if (')]}'.indexOf(initial) !== -1) {\n                        this.parenlev -= 1;\n                    }\n                    if (callback(T_OP, token, begin, end, line)) {\n                        return Done;\n                    }\n                }\n            }\n            else {\n                begin[COLUMN] = pos;\n                end[COLUMN] = pos + 1;\n                if (callback(T_ERRORTOKEN, line.charAt(pos), begin, end, line)) {\n                    return Done;\n                }\n                pos += 1;\n            }\n        }\n        return false;\n    };\n    return Tokenizer;\n}());\nexport { Tokenizer };\nfunction group(x, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {\n    var args = Array.prototype.slice.call(arguments);\n    return '(' + args.join('|') + ')';\n}\nfunction maybe(x) { return group.apply(null, arguments) + \"?\"; }\nfunction contains(a, obj) {\n    var i = a.length;\n    while (i--) {\n        if (a[i] === obj) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction rstrip(input, what) {\n    var i;\n    for (i = input.length; i > 0; --i) {\n        if (what.indexOf(input.charAt(i - 1)) === -1)\n            break;\n    }\n    return input.substring(0, i);\n}\n/**\n * @param message\n * @param begin\n * @param end\n * @param {string|undefined} text\n */\nfunction indentationError(message, begin, end, text) {\n    assert(Array.isArray(begin), \"begin must be an Array\");\n    assert(Array.isArray(end), \"end must be an Array\");\n    var e = new SyntaxError(message /*, fileName*/);\n    e.name = \"IndentationError\";\n    if (begin) {\n        e['lineNumber'] = begin[LINE];\n        e['columnNumber'] = begin[COLUMN];\n    }\n    return e;\n}\n","import { assert } from './asserts';\nimport { isNumber, isString } from './base';\n/**\n *\n */\nvar TokenError = (function () {\n    function TokenError(message, lineNumber, columnNumber) {\n        assert(isString(message), \"message must be a string\");\n        assert(isNumber(lineNumber), \"lineNumber must be a number\");\n        assert(isNumber(columnNumber), \"columnNumber must be a number\");\n        this.name = \"TokenError\";\n        this.message = message;\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }\n    return TokenError;\n}());\nexport { TokenError };\n","/**\n * Null function used for default values of callbacks, etc.\n */\nexport function nullFunction() { }\n/**\n * When defining a class Foo with an abstract method bar(), you can do:\n * Foo.prototype.bar = base.abstractMethod\n *\n * Now if a subclass of Foo fails to override bar(), an error will be thrown\n * when bar() is invoked.\n *\n * Note: This does not take the name of the function to override as an argument\n * because that would make it more difficult to obfuscate our JavaScript code.\n *\n * @type {!Function}\n * @throws {Error} when invoked to indicate the method should be overridden.\n */\nexport function abstractMethod() {\n    throw Error('unimplemented abstract method');\n}\n// ==============================================================================\n// Language Enhancements\n// ==============================================================================\n/**\n * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\n * operator in such a way that null returns 'null' and arrays return 'array'.\n * @param {*} value The value to get the type of.\n * @return {string} The name of the type.\n */\nexport function typeOf(value) {\n    var s = typeof value;\n    if (s === 'object') {\n        if (value) {\n            // Check these first, so we can avoid calling Object.prototype.toString if\n            // possible.\n            //\n            // IE improperly marshals tyepof across execution contexts, but a\n            // cross-context object will still return false for \"instanceof Object\".\n            if (value instanceof Array) {\n                return 'array';\n            }\n            else if (value instanceof Object) {\n                return s;\n            }\n            // HACK: In order to use an Object prototype method on the arbitrary\n            //   value, the compiler requires the value be cast to type Object,\n            //   even though the ECMA spec explicitly allows it.\n            var className = Object.prototype.toString.call(\n            /** @type {Object} */ (value));\n            // In Firefox 3.6, attempting to access iframe window objects' length\n            // property throws an NS_ERROR_FAILURE, so we need to special-case it\n            // here.\n            if (className === '[object Window]') {\n                return 'object';\n            }\n            // We cannot always use constructor == Array or instanceof Array because\n            // different frames have different Array objects. In IE6, if the iframe\n            // where the array was created is destroyed, the array loses its\n            // prototype. Then dereferencing val.splice here throws an exception, so\n            // we can't use base.isFunction. Calling typeof directly returns 'unknown'\n            // so that will work. In this case, this function will return false and\n            // most array functions will still work because the array is still\n            // array-like (supports length and []) even though it has lost its\n            // prototype.\n            // Mark Miller noticed that Object.prototype.toString\n            // allows access to the unforgeable [[Class]] property.\n            //  15.2.4.2 Object.prototype.toString ( )\n            //  When the toString method is called, the following steps are taken:\n            //      1. Get the [[Class]] property of this object.\n            //      2. Compute a string value by concatenating the three strings\n            //         \"[object \", Result(1), and \"]\".\n            //      3. Return Result(2).\n            // and this behavior survives the destruction of the execution context.\n            if ((className === '[object Array]' ||\n                // In IE all non value types are wrapped as objects across window\n                // boundaries (not iframe though) so we have to do object detection\n                // for this edge case.\n                typeof value.length === 'number' &&\n                    typeof value.splice !== 'undefined' &&\n                    typeof value.propertyIsEnumerable !== 'undefined' &&\n                    !value.propertyIsEnumerable('splice'))) {\n                return 'array';\n            }\n            // HACK: There is still an array case that fails.\n            //     function ArrayImpostor() {}\n            //     ArrayImpostor.prototype = [];\n            //     var impostor = new ArrayImpostor;\n            // this can be fixed by getting rid of the fast path\n            // (value instanceof Array) and solely relying on\n            // (value && Object.prototype.toString.vall(value) === '[object Array]')\n            // but that would require many more function calls and is not warranted\n            // unless closure code is receiving objects from untrusted sources.\n            // IE in cross-window calls does not correctly marshal the function type\n            // (it appears just as an object) so we cannot use just typeof val ==\n            // 'function'. However, if the object has a call property, it is a\n            // function.\n            if ((className === '[object Function]' ||\n                typeof value.call !== 'undefined' &&\n                    typeof value.propertyIsEnumerable !== 'undefined' &&\n                    !value.propertyIsEnumerable('call'))) {\n                return 'function';\n            }\n        }\n        else {\n            return 'null';\n        }\n    }\n    else if (s === 'function' && typeof value.call === 'undefined') {\n        // In Safari typeof nodeList returns 'function', and on Firefox typeof\n        // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We\n        // would like to return object for those and we can detect an invalid\n        // function by making sure that the function object has a call method.\n        return 'object';\n    }\n    return s;\n}\n/**\n * Returns true if the specified value is not undefined.\n * WARNING: Do not use this to test if an object has a property. Use the in\n * operator instead.  Additionally, this function assumes that the global\n * undefined variable has not been redefined.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is defined.\n */\nexport function isDef(val) {\n    return val !== undefined;\n}\n/**\n * Returns true if the specified value is null.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is null.\n */\nexport function isNull(val) {\n    return val === null;\n}\n/**\n * Returns true if the specified value is defined and not null.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is defined and not null.\n */\nexport function isDefAndNotNull(val) {\n    // Note that undefined == null.\n    return val != null;\n}\n/**\n * Returns true if the specified value is an array.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\nexport function isArray(val) {\n    return typeOf(val) === 'array';\n}\n/**\n * Returns true if the object looks like a Date. To qualify as Date-like the\n * value needs to be an object and have a getFullYear() function.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a like a Date.\n */\nexport function isDateLike(val) {\n    return isObject(val) && typeof val.getFullYear === 'function';\n}\n/**\n * Returns true if the specified value is a string.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a string.\n */\nexport function isString(val) {\n    return typeof val === 'string';\n}\n/**\n * Returns true if the specified value is a boolean.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is boolean.\n */\nexport function isBoolean(val) {\n    return typeof val === 'boolean';\n}\n/**\n * Returns true if the specified value is a number.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a number.\n */\nexport function isNumber(val) {\n    return typeof val === 'number';\n}\n/**\n * Returns true if the specified value is a function.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a function.\n */\nexport function isFunction(val) {\n    return typeOf(val) === 'function';\n}\n/**\n * Returns true if the specified value is an object.  This includes arrays and\n * functions.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an object.\n */\nexport function isObject(val) {\n    var type = typeof val;\n    return type === 'object' && val !== null || type === 'function';\n    // return Object(val) === val also works, but is slower, especially if val is\n    // not an object.\n}\n","/**\n * We're looking for something that is truthy, not just true.\n */\nexport function assert(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nexport function fail(message) {\n    assert(false, message);\n}\n","// DO NOT MODIFY. File automatically generated by pgen/parser/main.py\nimport { Tokens } from './Tokens';\n/**\n * Mapping from operator textual symbols to token symbolic constants.\n */\nexport var OpMap = {\n    \"(\": Tokens.T_LPAR,\n    \")\": Tokens.T_RPAR,\n    \":\": Tokens.T_COLON,\n    \"->\": Tokens.T_RARROW\n};\n/**\n * An Arc is a pair, represented in an array, consisting a label and a to-state.\n */\nexport var ARC_SYMBOL_LABEL = 0;\nexport var ARC_TO_STATE = 1;\n/**\n *\n */\nexport var IDX_DFABT_DFA = 0;\nexport var IDX_DFABT_BEGIN_TOKENS = 1;\nexport var IDX_LABEL_TOKEN_OR_SYMBOL = 0;\nexport var IDX_LABEL_NAME = 1;\n/**\n *\n */\nexport var ParseTables = {\n    sym: { Start: 256, funcdef: 257, functype: 258 },\n    number2symbol: { 256: 'Start', 257: 'funcdef', 258: 'functype' },\n    dfas: { 256: [[[[1, 1]], [[2, 1], [3, 2]], [[0, 2]]], { 4: 1 }],\n        257: [[[[4, 1]],\n                [[5, 2]],\n                [[6, 3]],\n                [[7, 4]],\n                [[8, 5], [9, 6]],\n                [[5, 7]],\n                [[8, 5]],\n                [[0, 7]]],\n            { 4: 1 }],\n        258: [[[[10, 1]], [[5, 2]], [[0, 2]]], { 10: 1 }] },\n    states: [[[[1, 1]], [[2, 1], [3, 2]], [[0, 2]]],\n        [[[4, 1]],\n            [[5, 2]],\n            [[6, 3]],\n            [[7, 4]],\n            [[8, 5], [9, 6]],\n            [[5, 7]],\n            [[8, 5]],\n            [[0, 7]]],\n        [[[10, 1]], [[5, 2]], [[0, 2]]]],\n    labels: [[0, 'EMPTY'],\n        [257, null],\n        [4, null],\n        [0, null],\n        [1, 'def'],\n        [1, null],\n        [7, null],\n        [8, null],\n        [11, null],\n        [258, null],\n        [55, null]],\n    keywords: { 'def': 4 },\n    tokens: { 0: 3, 1: 5, 4: 2, 7: 6, 8: 7, 11: 8, 55: 10 },\n    start: 256\n};\n// Nothing more to see here.\n","/**\n * These must align with the values in token.py\n */\nexport var Tokens;\n(function (Tokens) {\n    /**\n     * Used for trying a new state.\n     */\n    Tokens[Tokens[\"T_ENDMARKER\"] = 0] = \"T_ENDMARKER\";\n    /**\n     * Used for keywords and identifiers. The grammar maintains a map of keywords to symbols.\n     */\n    Tokens[Tokens[\"T_NAME\"] = 1] = \"T_NAME\";\n    Tokens[Tokens[\"T_NUMBER\"] = 2] = \"T_NUMBER\";\n    Tokens[Tokens[\"T_STRING\"] = 3] = \"T_STRING\";\n    Tokens[Tokens[\"T_NEWLINE\"] = 4] = \"T_NEWLINE\";\n    Tokens[Tokens[\"T_INDENT\"] = 5] = \"T_INDENT\";\n    Tokens[Tokens[\"T_DEDENT\"] = 6] = \"T_DEDENT\";\n    Tokens[Tokens[\"T_LPAR\"] = 7] = \"T_LPAR\";\n    Tokens[Tokens[\"T_RPAR\"] = 8] = \"T_RPAR\";\n    Tokens[Tokens[\"T_COLON\"] = 11] = \"T_COLON\";\n    Tokens[Tokens[\"T_OP\"] = 52] = \"T_OP\";\n    Tokens[Tokens[\"T_COMMENT\"] = 53] = \"T_COMMENT\";\n    Tokens[Tokens[\"T_NL\"] = 54] = \"T_NL\";\n    Tokens[Tokens[\"T_RARROW\"] = 55] = \"T_RARROW\";\n    Tokens[Tokens[\"T_ERRORTOKEN\"] = 58] = \"T_ERRORTOKEN\";\n    Tokens[Tokens[\"T_N_TOKENS\"] = 59] = \"T_N_TOKENS\";\n    /**\n     * Used to determine the boundary between terminals and non-terminals.\n     */\n    Tokens[Tokens[\"T_NT_OFFSET\"] = 256] = \"T_NT_OFFSET\";\n})(Tokens || (Tokens = {}));\n"],"names":["SourceKind","tslib_1.__extends","T_OP","T_NL","T_NAME","T_COMMENT","T_ENDMARKER"],"mappings":"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"}