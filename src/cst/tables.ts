// DO NOT MODIFY. File automatically generated by pgen/parser/main.py
import { Tokens } from './Tokens';

/**
 * Mapping from operator textual symbols to token symbolic constants.
 */
export const OpMap: { [op: string]: Tokens } = {
    "(": Tokens.T_LPAR,
    ")": Tokens.T_RPAR,
    ":": Tokens.T_COLON,
    "->": Tokens.T_RARROW
};


/**
 * An Arc is a pair, represented in an array, consisting a label and a to-state.
 */
export const ARC_SYMBOL_LABEL = 0;
export const ARC_TO_STATE = 1;
export type Arc = [number, number];

/**
 *
 */
export const IDX_DFABT_DFA = 0;
export const IDX_DFABT_BEGIN_TOKENS = 1;
export type State = Arc[];
export type Dfa = State[];
export type BeginTokens = { [value: number]: number };
export type DfaAndBeginTokens = [Dfa, BeginTokens];

export const IDX_LABEL_TOKEN_OR_SYMBOL = 0;
export const IDX_LABEL_NAME = 1;
export type Label = [number, string | null];

/**
 * Describes the shape of the ParseTables objects.
 */
export interface Grammar {
    /**
     * The number of the grammar's start symbol.
     */
    start: number;
    /**
     * A dict mapping symbol numbers to (DFA, first)
     * pairs, where DFA is an item from the states list
     * above, and first is a set of tokens that can
     * begin this grammar rule (represented by a dict
     * whose values are always 1).
     */
    dfas: { [symbolId: number]: DfaAndBeginTokens };
    /**
     * The first index is the symbol for a transition (a number).
     * The second index is the haman-readable decode of the symbol, if it exists, otherwise `null`.
     * Not all symbols have human-readable names.
     * All symbols that have human-readable names are keywords, with one exception.
     * The symbol 0 (zero) is an exceptional symbol and has the human-readavble name 'EMPTY'.
     *
     * a list of (x, y) pairs where x is either a token
     * number or a symbol number, and y is either None
     * or a string; the strings are keywords.  The label
     * number is the index in this list; label numbers
     * are used to mark state transitions (arcs) in the
     * DFAs.
     */
    labels: Label[];
    /**
     * A mapping from a keyword to the symbol that has been assigned to it.
     */
    keywords: { [keyword: string]: number };
    /**
     * A mapping from a token to a symbol.
     * A dict mapping token numbers to arc labels
     */
    tokens: { [token: number]: number };
    /**
     * Actually maps from the node constructor name.
     */
    sym: { [name: string]: number };
    /**
     * A lookup table for converting the value in the `sym` mapping back to a string.
     */
    number2symbol: { [value: number]: string };
    /**
     * A list of DFAs, where each DFA is a list of
     * states, each state is is a list of arcs, and each
     * arc is a (i, j) pair where i is a label and j is
     * a state number.  The DFA number is the index into
     * this list.  (This name is slightly confusing.)
     * Final states are represented by a special arc of
     * the form (0, j) where j is its own state number.
     */
    states: Dfa[];
}

/**
 *
 */
export const ParseTables: Grammar = {
sym:
{Start: 256, funcdef: 257, functype: 258},
number2symbol:
{256: 'Start', 257: 'funcdef', 258: 'functype'},
dfas:
{256: [[[[1, 1]], [[2, 1], [3, 2]], [[0, 2]]], {4: 1}],
 257: [[[[4, 1]],
        [[5, 2]],
        [[6, 3]],
        [[7, 4]],
        [[8, 5], [9, 6]],
        [[5, 7]],
        [[8, 5]],
        [[0, 7]]],
       {4: 1}],
 258: [[[[10, 1]], [[5, 2]], [[0, 2]]], {10: 1}]},
states:
[[[[1, 1]], [[2, 1], [3, 2]], [[0, 2]]],
 [[[4, 1]],
  [[5, 2]],
  [[6, 3]],
  [[7, 4]],
  [[8, 5], [9, 6]],
  [[5, 7]],
  [[8, 5]],
  [[0, 7]]],
 [[[10, 1]], [[5, 2]], [[0, 2]]]],
labels:
[[0, 'EMPTY'],
 [257, null],
 [4, null],
 [0, null],
 [1, 'def'],
 [1, null],
 [7, null],
 [8, null],
 [11, null],
 [258, null],
 [55, null]],
keywords:
{'def': 4},
tokens:
{0: 3, 1: 5, 4: 2, 7: 6, 8: 7, 11: 8, 55: 10},
start: 256
};

// Nothing more to see here.
